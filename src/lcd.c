/******************************************************************************
                (С) ООО "ЛМТ", Санкт-Петербург, Россия, 2002.
                http://lmt.cs.ifmo.ru, tel.: +7-812-233-3096,
                mailto: lmt@d1.ifmo.ru

        Данный файл является свободно распространяемым примером работы
    с жидкокристаллическим  индикатором  учебного  стенда  SDK-1.1  на
    языке Си  (компилятор  Keil  C  фирмы  KEIL  ELEKTRONIK  GmbH)   и
    предназначен для иллюстрации работы с устройством.
        Данный  программный   модуль   не    подвергался   тщательному
    тестированию  и  может   содержать   ошибки.   Авторы   не   несут 
    ответственности за потерю  информации  и  иные  возможные  вредные
    последствия использования данного программного  модуля  в  составе
    программных проектов.
        Данный файл может подвергаться любым изменениям, но  не  может
    распространяться в коммерческих целях  и  в  составе  коммерческих
    программных продуктов.
    

Файл:       lcd.c
Версия:     1.0.0
Автор:      LAN
Описание:   Набор демонстрационного программного обеспечения для стенда
            SDK-1.1. Работа с жидкокристаллическим индикатором. данный
            модуль использует модуль работы с функциональным расширителем
            центрального процессора на базе ПЛИС MAX3064 (3128) - max.c,
            max.h.

Изменения:
-------------------------------------------------------------------------------
N Дата     Версия   Автор               Описание   
-------------------------------------------------------------------------------
1 09.04.02  1.0.0   LAN     Создан
******************************************************************************/
#include "lcd.h"    //Описания команд (константы)
#include "max.h"    //Описание портов ПЛИС MAX3064 (3128)

/*----------------------------------------------------------------------------
            Переменные и флаги
 -----------------------------------------------------------------------------*/
static bit CurPosCtrl=1;    //Отслеживание драйвером текущей позиции курсора
                            //ЖКИ (1 - вкл., 0 - выкл.)

//Текущая позиция курсора. Имеют смысл, только если CurPosCtrl = 1.
//Переменные используются функциями LCD_Putch(), LCD_GotoXY()
static char cur_x=0;//0-15
static bit cur_y=0; //0/1


/*----------------------------------------------------------------------------
                    Функции
 -----------------------------------------------------------------------------*/

/**----------------------------------------------------------------------------
                        SwitchCurPosControl()
-------------------------------------------------------------------------------
Включение/выключение отслеживания текущей позиции курсора. После включения
контроля желательно установить текущую позицию заново (LCD_GotoXY()), т.к. 
значение переменных cur_x и cur_y могут содержать неправильные значения.

Вход:       bit o: o = 1 - включить контроль
                   o = 0 - выключить контроль
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void SwitchCurPosControl(bit o)
{
    CurPosCtrl=o;
}

/**----------------------------------------------------------------------------
                        Strobe()
-------------------------------------------------------------------------------
Подача сигнала E интерфейса ПЛИС<->ЖКИ на время не менее 500 нс. Одновременно
подаются сигналы R/W и RS в заданном аргументом c значении.

Вход:       char c - биты 1,2 определяют значения сигналов R/W и RS:
                бит 1: 1 - R/W = 1 (чтение)
                       0 - R/W = 0 (запись)
                бит 2: 1 - RS = 1 (выбрать регистр данных ЖКИ)
                       0 - RS = 0 (выбрать регистр команд ЖКИ)
                бит 3: должен быть равным 1!
                Значения остальных бит не принимаются во внимание.

Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void Strobe(char c)
{
unsigned int i;

    WriteMax(C_IND,c | 0x1);  //Установка строба E
    WriteMax(C_IND,c & 0xFE); //Сброс строба

    for (i=0;i<300;i++)continue; //Задержка на время исполнения команды 
                                 //(>1.59ms)
    
}

/**----------------------------------------------------------------------------
                        LCD_SwitchCursor()
-------------------------------------------------------------------------------
Установка режима курсора: включение/выключение курсора, вкл./выкл. мигания

Вход:       bit cursor: 1 - включить курсор,
                        0 - выключить курсор;
            bit blink:  1 - включить мигание,
                        0 - выключить мигание.

Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void LCD_SwitchCursor(bit cursor, bit blink)
{
unsigned char i=0;

    WriteMax( DATA_IND, DISPLAY_CTRL |
                        DISPLAY_ON |
                        ((cursor)?CURSOR_ON:0) |
                        ((blink)?BLINK:0) );

    Strobe(0x8); //R/W = 0; RS = 0

}


/**----------------------------------------------------------------------------
                        LCD_Clear()
-------------------------------------------------------------------------------
Очистка ЖКИ и установка текущей позиции на первый символ первой строки

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void LCD_Clear(void)
{
//int i;

    WriteMax(DATA_IND, CLEAR);
    Strobe(0x8); //clear
    cur_x = 0;
    cur_y = 0;
//    for(i=0; i<1600; i++)continue;
}


/**----------------------------------------------------------------------------
                        InitLCD()
-------------------------------------------------------------------------------
Инициализация ЖКИ.

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void InitLCD(void)
{
unsigned short i;

    for(i=0; i<4000; i++)continue; //Ожидание включения ЖКИ (>15мс после подачи 
                                   //питания)
//    cmd = 0x30;  //
    WriteMax(DATA_IND, FUNCTION_SET|EIGHT_BITS);
    Strobe(0x8);
    for(i=0; i<1500; i++)continue; //Ожидание, предусмотренное протоколом
                                   //инициализации (>4.1мс)
//    cmd = 0x30;  //

    WriteMax(DATA_IND, FUNCTION_SET|EIGHT_BITS);
    Strobe(0x8);
    for(i=0; i<50; i++)continue;   //Ожидание, предусмотренное протоколом
                                   //инициализации (>4.1мс)
//    cmd = 0x30;  //
    WriteMax(DATA_IND, FUNCTION_SET|EIGHT_BITS);
    Strobe(0x8);
//    for(i=0; i<100; i++)continue;

//    cmd = 0x38;  //
    WriteMax(DATA_IND, FUNCTION_SET|EIGHT_BITS|TWO_LINE);
    Strobe(0x8);

//    cmd = 0x08;  //
    WriteMax(DATA_IND, DISPLAY_CTRL); //Display off
    Strobe(0x8);

//    cmd = 0x01;  //
    WriteMax(DATA_IND, CLEAR); 
    Strobe(0x8);

//    for(i=0; i<1600; i++)continue;
    WriteMax(DATA_IND, ENTRY_MODE|INCR);
    Strobe(0x8);
//    cmd = 0x0F;  //Display ON
    WriteMax(DATA_IND, DISPLAY_CTRL|DISPLAY_ON); //Cursor OFF, Blinking OFF
    Strobe(0x8);
}

/**----------------------------------------------------------------------------
                        LCD_Putch()
-------------------------------------------------------------------------------
Вывод на текущую позицию символа. Текущая позиция определяется в зависимости
от значения флага CurPosCtrl: если он установлен, то по переменным cur_x, cur_y
(при этом она увеличивается с каждым выведенным символом);
если он сброшен, то по внутреннему указателю ЖКИ (не увеличивается по выводу
символа).

Вход:       char ch - выводимый символ
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void LCD_Putch(char ch)
{

    if(CurPosCtrl)
    {
        LCD_GotoXY(cur_x,cur_y);
        if(++cur_x>15)cur_x=0,cur_y=~cur_y;
    }

    WriteMax(DATA_IND,ch);
    Strobe(0xC); //R/W = 0, RS = 1 (данные)
}

/**----------------------------------------------------------------------------
                        LCD_GotoXY()
-------------------------------------------------------------------------------
Установка текущей позиции ЖКИ. Сохранение ее во внутренних переменных драйвера.

Вход:       uchar x - номер столбца (позиции в строке): 0..15.
            bit y - номер строки: 0..1.
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void LCD_GotoXY(unsigned char x,bit y)
{
    WriteMax(DATA_IND,RAM_DD|(x+((y)?0x40:0)));
    Strobe(0x8); //set ram
    cur_x = x;
    cur_y = y;
}

/**----------------------------------------------------------------------------
                        LCD_Type()
-------------------------------------------------------------------------------
Вывод ASCIIZ-строки на ЖКИ начиная с текущей позиции.

Вход:       char *s - указатель на строку.
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void LCD_Type(char* s)
{
bit t = CurPosCtrl;

    SwitchCurPosControl(1);
    while(*s)
        LCD_Putch(*s++);

    SwitchCurPosControl(t);
}


void LCD_Print(unsigned char* s, bit y, char last_position)
{
	char x, len = 16, start, offset;
	unsigned char ch;	
	bit t = CurPosCtrl;

	SwitchCurPosControl(1);
	
	if(last_position < len) 
	{
		start = len - 1 - last_position;
		offset = last_position - len + 1;
	}
	else
	{
		start = 1;
		offset = last_position - len - 1;
	}
	
	cur_y = y;
	for(x=1; x<len; x++)
	{
		cur_x = x;
		if(CurPosCtrl)
        LCD_GotoXY(cur_x,cur_y);
		
		if(x >= start)
			ch = s[offset+x];
		else
			ch = ' ';
		
		WriteMax(DATA_IND,ch);
    Strobe(0xC);	
	}
	
	SwitchCurPosControl(t);
}

void LCD_Print_char(unsigned char ch, unsigned char x, bit y)
{
	bit t = CurPosCtrl;
	cur_x = x;
	cur_y = y;
	
	SwitchCurPosControl(1);
	
	LCD_GotoXY(cur_x,cur_y);
	WriteMax(DATA_IND,ch);
  Strobe(0xC);
	
	SwitchCurPosControl(t);
}

void LCD_clean_data(bit y)
{
	char x;
	for(x=1;x<16;x++)
	{
		LCD_Print_char(' ', x, y);
	}
}